// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGECLASS_H_
#define FLATBUFFERS_GENERATED_MESSAGECLASS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct HostPayloadType;
struct HostPayloadTypeBuilder;

struct JoinPayloadType;
struct JoinPayloadTypeBuilder;

struct FBLeaderboardPlayer;
struct FBLeaderboardPlayerBuilder;

struct LeaderboardInformationPayload;
struct LeaderboardInformationPayloadBuilder;

struct LeaderboardHostSkipPayload;
struct LeaderboardHostSkipPayloadBuilder;

struct LeaderboardPayloadType;
struct LeaderboardPayloadTypeBuilder;

struct PlayerBailout;
struct PlayerBailoutBuilder;

struct BusinessBailoutHostPayload;
struct BusinessBailoutHostPayloadBuilder;

struct BusinessBailoutPlayerInputPayload;
struct BusinessBailoutPlayerInputPayloadBuilder;

struct BusinessBailoutPlayerPayload;
struct BusinessBailoutPlayerPayloadBuilder;

struct BusinessBailoutResultPayload;
struct BusinessBailoutResultPayloadBuilder;

struct FBBusinessBailoutResultPair;
struct FBBusinessBailoutResultPairBuilder;

struct CrazyCountingHostEntitiesPayload;
struct CrazyCountingHostEntitiesPayloadBuilder;

struct FBCrazyCountingEntity;
struct FBCrazyCountingEntityBuilder;

struct CrazyCountingPlayerInputPayload;
struct CrazyCountingPlayerInputPayloadBuilder;

struct CrazyCountingPlayerUpdatePayload;
struct CrazyCountingPlayerUpdatePayloadBuilder;

struct CrazyCountingResultPayload;
struct CrazyCountingResultPayloadBuilder;

struct FBCrazyCountingResultPair;
struct FBCrazyCountingResultPairBuilder;

struct MemoryMixerGridRow;
struct MemoryMixerGridRowBuilder;

struct MemoryMixerGridCell;
struct MemoryMixerGridCellBuilder;

struct MemoryMixerGridPayload;
struct MemoryMixerGridPayloadBuilder;

struct MemoryMixerPlayerInputPayload;
struct MemoryMixerPlayerInputPayloadBuilder;

struct MemoryMixerPlayerSubmittedPayload;
struct MemoryMixerPlayerSubmittedPayloadBuilder;

struct MemoryMixerResultPayload;
struct MemoryMixerResultPayloadBuilder;

struct FBMemoryMixerResultPair;
struct FBMemoryMixerResultPairBuilder;

struct MemoryMixerRoundResultPayload;
struct MemoryMixerRoundResultPayloadBuilder;

struct MiniGameIntroductionPayload;
struct MiniGameIntroductionPayloadBuilder;

struct MiniGamePayloadType;
struct MiniGamePayloadTypeBuilder;

struct FBPlayer;
struct FBPlayerBuilder;

struct PartyPrepHostInformationPayload;
struct PartyPrepHostInformationPayloadBuilder;

struct PartyPrepHostStartGamePayload;
struct PartyPrepHostStartGamePayloadBuilder;

struct PartyPrepPlayerInformationPayload;
struct PartyPrepPlayerInformationPayloadBuilder;

struct PartyPrepPayloadType;
struct PartyPrepPayloadTypeBuilder;

struct Message;
struct MessageBuilder;

enum LeaderboardType : int8_t {
  LeaderboardType_LeaderboardInformation = 0,
  LeaderboardType_LeaderboardHostSkip = 1,
  LeaderboardType_MIN = LeaderboardType_LeaderboardInformation,
  LeaderboardType_MAX = LeaderboardType_LeaderboardHostSkip
};

inline const LeaderboardType (&EnumValuesLeaderboardType())[2] {
  static const LeaderboardType values[] = {
    LeaderboardType_LeaderboardInformation,
    LeaderboardType_LeaderboardHostSkip
  };
  return values;
}

inline const char * const *EnumNamesLeaderboardType() {
  static const char * const names[3] = {
    "LeaderboardInformation",
    "LeaderboardHostSkip",
    nullptr
  };
  return names;
}

inline const char *EnumNameLeaderboardType(LeaderboardType e) {
  if (::flatbuffers::IsOutRange(e, LeaderboardType_LeaderboardInformation, LeaderboardType_LeaderboardHostSkip)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLeaderboardType()[index];
}

enum LeaderboardPayload : uint8_t {
  LeaderboardPayload_NONE = 0,
  LeaderboardPayload_LeaderboardInformationPayload = 1,
  LeaderboardPayload_LeaderboardHostSkipPayload = 2,
  LeaderboardPayload_MIN = LeaderboardPayload_NONE,
  LeaderboardPayload_MAX = LeaderboardPayload_LeaderboardHostSkipPayload
};

inline const LeaderboardPayload (&EnumValuesLeaderboardPayload())[3] {
  static const LeaderboardPayload values[] = {
    LeaderboardPayload_NONE,
    LeaderboardPayload_LeaderboardInformationPayload,
    LeaderboardPayload_LeaderboardHostSkipPayload
  };
  return values;
}

inline const char * const *EnumNamesLeaderboardPayload() {
  static const char * const names[4] = {
    "NONE",
    "LeaderboardInformationPayload",
    "LeaderboardHostSkipPayload",
    nullptr
  };
  return names;
}

inline const char *EnumNameLeaderboardPayload(LeaderboardPayload e) {
  if (::flatbuffers::IsOutRange(e, LeaderboardPayload_NONE, LeaderboardPayload_LeaderboardHostSkipPayload)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLeaderboardPayload()[index];
}

template<typename T> struct LeaderboardPayloadTraits {
  static const LeaderboardPayload enum_value = LeaderboardPayload_NONE;
};

template<> struct LeaderboardPayloadTraits<LeaderboardInformationPayload> {
  static const LeaderboardPayload enum_value = LeaderboardPayload_LeaderboardInformationPayload;
};

template<> struct LeaderboardPayloadTraits<LeaderboardHostSkipPayload> {
  static const LeaderboardPayload enum_value = LeaderboardPayload_LeaderboardHostSkipPayload;
};

bool VerifyLeaderboardPayload(::flatbuffers::Verifier &verifier, const void *obj, LeaderboardPayload type);
bool VerifyLeaderboardPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Input : int8_t {
  Input_Increase = 0,
  Input_Decrease = 1,
  Input_Submit = 2,
  Input_MIN = Input_Increase,
  Input_MAX = Input_Submit
};

inline const Input (&EnumValuesInput())[3] {
  static const Input values[] = {
    Input_Increase,
    Input_Decrease,
    Input_Submit
  };
  return values;
}

inline const char * const *EnumNamesInput() {
  static const char * const names[4] = {
    "Increase",
    "Decrease",
    "Submit",
    nullptr
  };
  return names;
}

inline const char *EnumNameInput(Input e) {
  if (::flatbuffers::IsOutRange(e, Input_Increase, Input_Submit)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInput()[index];
}

enum MemoryMixerIconType : int8_t {
  MemoryMixerIconType_BALLOON = 0,
  MemoryMixerIconType_CAKE = 1,
  MemoryMixerIconType_CONFETTI = 2,
  MemoryMixerIconType_CONFETTI2 = 3,
  MemoryMixerIconType_SMILEY = 4,
  MemoryMixerIconType_EMPTY = 5,
  MemoryMixerIconType_MIN = MemoryMixerIconType_BALLOON,
  MemoryMixerIconType_MAX = MemoryMixerIconType_EMPTY
};

inline const MemoryMixerIconType (&EnumValuesMemoryMixerIconType())[6] {
  static const MemoryMixerIconType values[] = {
    MemoryMixerIconType_BALLOON,
    MemoryMixerIconType_CAKE,
    MemoryMixerIconType_CONFETTI,
    MemoryMixerIconType_CONFETTI2,
    MemoryMixerIconType_SMILEY,
    MemoryMixerIconType_EMPTY
  };
  return values;
}

inline const char * const *EnumNamesMemoryMixerIconType() {
  static const char * const names[7] = {
    "BALLOON",
    "CAKE",
    "CONFETTI",
    "CONFETTI2",
    "SMILEY",
    "EMPTY",
    nullptr
  };
  return names;
}

inline const char *EnumNameMemoryMixerIconType(MemoryMixerIconType e) {
  if (::flatbuffers::IsOutRange(e, MemoryMixerIconType_BALLOON, MemoryMixerIconType_EMPTY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMemoryMixerIconType()[index];
}

enum GameStateType : int8_t {
  GameStateType_BusinessBailoutHost = 0,
  GameStateType_BusinessBailoutPlayerInput = 1,
  GameStateType_BusinessBailoutPlayer = 2,
  GameStateType_BusinessBailoutResult = 3,
  GameStateType_CrazyCountingHostEntities = 4,
  GameStateType_CrazyCountingPlayerInput = 5,
  GameStateType_CrazyCountingPlayerUpdate = 6,
  GameStateType_CrazyCountingResult = 7,
  GameStateType_MemoryMixerGrid = 8,
  GameStateType_MemoryMixerPlayerInput = 9,
  GameStateType_MemoryMixerPlayerSubmitted = 10,
  GameStateType_MemoryMixerResult = 11,
  GameStateType_MemoryMixerRoundResult = 12,
  GameStateType_MiniGameIntroduction = 13,
  GameStateType_MIN = GameStateType_BusinessBailoutHost,
  GameStateType_MAX = GameStateType_MiniGameIntroduction
};

inline const GameStateType (&EnumValuesGameStateType())[14] {
  static const GameStateType values[] = {
    GameStateType_BusinessBailoutHost,
    GameStateType_BusinessBailoutPlayerInput,
    GameStateType_BusinessBailoutPlayer,
    GameStateType_BusinessBailoutResult,
    GameStateType_CrazyCountingHostEntities,
    GameStateType_CrazyCountingPlayerInput,
    GameStateType_CrazyCountingPlayerUpdate,
    GameStateType_CrazyCountingResult,
    GameStateType_MemoryMixerGrid,
    GameStateType_MemoryMixerPlayerInput,
    GameStateType_MemoryMixerPlayerSubmitted,
    GameStateType_MemoryMixerResult,
    GameStateType_MemoryMixerRoundResult,
    GameStateType_MiniGameIntroduction
  };
  return values;
}

inline const char * const *EnumNamesGameStateType() {
  static const char * const names[15] = {
    "BusinessBailoutHost",
    "BusinessBailoutPlayerInput",
    "BusinessBailoutPlayer",
    "BusinessBailoutResult",
    "CrazyCountingHostEntities",
    "CrazyCountingPlayerInput",
    "CrazyCountingPlayerUpdate",
    "CrazyCountingResult",
    "MemoryMixerGrid",
    "MemoryMixerPlayerInput",
    "MemoryMixerPlayerSubmitted",
    "MemoryMixerResult",
    "MemoryMixerRoundResult",
    "MiniGameIntroduction",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameStateType(GameStateType e) {
  if (::flatbuffers::IsOutRange(e, GameStateType_BusinessBailoutHost, GameStateType_MiniGameIntroduction)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameStateType()[index];
}

enum GameStatePayload : uint8_t {
  GameStatePayload_NONE = 0,
  GameStatePayload_BusinessBailoutHostPayload = 1,
  GameStatePayload_BusinessBailoutPlayerInputPayload = 2,
  GameStatePayload_BusinessBailoutPlayerPayload = 3,
  GameStatePayload_BusinessBailoutResultPayload = 4,
  GameStatePayload_CrazyCountingHostEntitiesPayload = 5,
  GameStatePayload_CrazyCountingPlayerInputPayload = 6,
  GameStatePayload_CrazyCountingPlayerUpdatePayload = 7,
  GameStatePayload_CrazyCountingResultPayload = 8,
  GameStatePayload_MemoryMixerGridPayload = 9,
  GameStatePayload_MemoryMixerPlayerInputPayload = 10,
  GameStatePayload_MemoryMixerPlayerSubmittedPayload = 11,
  GameStatePayload_MemoryMixerResultPayload = 12,
  GameStatePayload_MemoryMixerRoundResultPayload = 13,
  GameStatePayload_MiniGameIntroductionPayload = 14,
  GameStatePayload_MIN = GameStatePayload_NONE,
  GameStatePayload_MAX = GameStatePayload_MiniGameIntroductionPayload
};

inline const GameStatePayload (&EnumValuesGameStatePayload())[15] {
  static const GameStatePayload values[] = {
    GameStatePayload_NONE,
    GameStatePayload_BusinessBailoutHostPayload,
    GameStatePayload_BusinessBailoutPlayerInputPayload,
    GameStatePayload_BusinessBailoutPlayerPayload,
    GameStatePayload_BusinessBailoutResultPayload,
    GameStatePayload_CrazyCountingHostEntitiesPayload,
    GameStatePayload_CrazyCountingPlayerInputPayload,
    GameStatePayload_CrazyCountingPlayerUpdatePayload,
    GameStatePayload_CrazyCountingResultPayload,
    GameStatePayload_MemoryMixerGridPayload,
    GameStatePayload_MemoryMixerPlayerInputPayload,
    GameStatePayload_MemoryMixerPlayerSubmittedPayload,
    GameStatePayload_MemoryMixerResultPayload,
    GameStatePayload_MemoryMixerRoundResultPayload,
    GameStatePayload_MiniGameIntroductionPayload
  };
  return values;
}

inline const char * const *EnumNamesGameStatePayload() {
  static const char * const names[16] = {
    "NONE",
    "BusinessBailoutHostPayload",
    "BusinessBailoutPlayerInputPayload",
    "BusinessBailoutPlayerPayload",
    "BusinessBailoutResultPayload",
    "CrazyCountingHostEntitiesPayload",
    "CrazyCountingPlayerInputPayload",
    "CrazyCountingPlayerUpdatePayload",
    "CrazyCountingResultPayload",
    "MemoryMixerGridPayload",
    "MemoryMixerPlayerInputPayload",
    "MemoryMixerPlayerSubmittedPayload",
    "MemoryMixerResultPayload",
    "MemoryMixerRoundResultPayload",
    "MiniGameIntroductionPayload",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameStatePayload(GameStatePayload e) {
  if (::flatbuffers::IsOutRange(e, GameStatePayload_NONE, GameStatePayload_MiniGameIntroductionPayload)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameStatePayload()[index];
}

template<typename T> struct GameStatePayloadTraits {
  static const GameStatePayload enum_value = GameStatePayload_NONE;
};

template<> struct GameStatePayloadTraits<BusinessBailoutHostPayload> {
  static const GameStatePayload enum_value = GameStatePayload_BusinessBailoutHostPayload;
};

template<> struct GameStatePayloadTraits<BusinessBailoutPlayerInputPayload> {
  static const GameStatePayload enum_value = GameStatePayload_BusinessBailoutPlayerInputPayload;
};

template<> struct GameStatePayloadTraits<BusinessBailoutPlayerPayload> {
  static const GameStatePayload enum_value = GameStatePayload_BusinessBailoutPlayerPayload;
};

template<> struct GameStatePayloadTraits<BusinessBailoutResultPayload> {
  static const GameStatePayload enum_value = GameStatePayload_BusinessBailoutResultPayload;
};

template<> struct GameStatePayloadTraits<CrazyCountingHostEntitiesPayload> {
  static const GameStatePayload enum_value = GameStatePayload_CrazyCountingHostEntitiesPayload;
};

template<> struct GameStatePayloadTraits<CrazyCountingPlayerInputPayload> {
  static const GameStatePayload enum_value = GameStatePayload_CrazyCountingPlayerInputPayload;
};

template<> struct GameStatePayloadTraits<CrazyCountingPlayerUpdatePayload> {
  static const GameStatePayload enum_value = GameStatePayload_CrazyCountingPlayerUpdatePayload;
};

template<> struct GameStatePayloadTraits<CrazyCountingResultPayload> {
  static const GameStatePayload enum_value = GameStatePayload_CrazyCountingResultPayload;
};

template<> struct GameStatePayloadTraits<MemoryMixerGridPayload> {
  static const GameStatePayload enum_value = GameStatePayload_MemoryMixerGridPayload;
};

template<> struct GameStatePayloadTraits<MemoryMixerPlayerInputPayload> {
  static const GameStatePayload enum_value = GameStatePayload_MemoryMixerPlayerInputPayload;
};

template<> struct GameStatePayloadTraits<MemoryMixerPlayerSubmittedPayload> {
  static const GameStatePayload enum_value = GameStatePayload_MemoryMixerPlayerSubmittedPayload;
};

template<> struct GameStatePayloadTraits<MemoryMixerResultPayload> {
  static const GameStatePayload enum_value = GameStatePayload_MemoryMixerResultPayload;
};

template<> struct GameStatePayloadTraits<MemoryMixerRoundResultPayload> {
  static const GameStatePayload enum_value = GameStatePayload_MemoryMixerRoundResultPayload;
};

template<> struct GameStatePayloadTraits<MiniGameIntroductionPayload> {
  static const GameStatePayload enum_value = GameStatePayload_MiniGameIntroductionPayload;
};

bool VerifyGameStatePayload(::flatbuffers::Verifier &verifier, const void *obj, GameStatePayload type);
bool VerifyGameStatePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum PartyPrepType : int8_t {
  PartyPrepType_PartyPrepHostInformation = 0,
  PartyPrepType_PartyPrepHostStartGame = 1,
  PartyPrepType_PartyPrepPlayerInformation = 2,
  PartyPrepType_MIN = PartyPrepType_PartyPrepHostInformation,
  PartyPrepType_MAX = PartyPrepType_PartyPrepPlayerInformation
};

inline const PartyPrepType (&EnumValuesPartyPrepType())[3] {
  static const PartyPrepType values[] = {
    PartyPrepType_PartyPrepHostInformation,
    PartyPrepType_PartyPrepHostStartGame,
    PartyPrepType_PartyPrepPlayerInformation
  };
  return values;
}

inline const char * const *EnumNamesPartyPrepType() {
  static const char * const names[4] = {
    "PartyPrepHostInformation",
    "PartyPrepHostStartGame",
    "PartyPrepPlayerInformation",
    nullptr
  };
  return names;
}

inline const char *EnumNamePartyPrepType(PartyPrepType e) {
  if (::flatbuffers::IsOutRange(e, PartyPrepType_PartyPrepHostInformation, PartyPrepType_PartyPrepPlayerInformation)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPartyPrepType()[index];
}

enum PartyPrepPayload : uint8_t {
  PartyPrepPayload_NONE = 0,
  PartyPrepPayload_PartyPrepHostInformationPayload = 1,
  PartyPrepPayload_PartyPrepHostStartGamePayload = 2,
  PartyPrepPayload_PartyPrepPlayerInformationPayload = 3,
  PartyPrepPayload_MIN = PartyPrepPayload_NONE,
  PartyPrepPayload_MAX = PartyPrepPayload_PartyPrepPlayerInformationPayload
};

inline const PartyPrepPayload (&EnumValuesPartyPrepPayload())[4] {
  static const PartyPrepPayload values[] = {
    PartyPrepPayload_NONE,
    PartyPrepPayload_PartyPrepHostInformationPayload,
    PartyPrepPayload_PartyPrepHostStartGamePayload,
    PartyPrepPayload_PartyPrepPlayerInformationPayload
  };
  return values;
}

inline const char * const *EnumNamesPartyPrepPayload() {
  static const char * const names[5] = {
    "NONE",
    "PartyPrepHostInformationPayload",
    "PartyPrepHostStartGamePayload",
    "PartyPrepPlayerInformationPayload",
    nullptr
  };
  return names;
}

inline const char *EnumNamePartyPrepPayload(PartyPrepPayload e) {
  if (::flatbuffers::IsOutRange(e, PartyPrepPayload_NONE, PartyPrepPayload_PartyPrepPlayerInformationPayload)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPartyPrepPayload()[index];
}

template<typename T> struct PartyPrepPayloadTraits {
  static const PartyPrepPayload enum_value = PartyPrepPayload_NONE;
};

template<> struct PartyPrepPayloadTraits<PartyPrepHostInformationPayload> {
  static const PartyPrepPayload enum_value = PartyPrepPayload_PartyPrepHostInformationPayload;
};

template<> struct PartyPrepPayloadTraits<PartyPrepHostStartGamePayload> {
  static const PartyPrepPayload enum_value = PartyPrepPayload_PartyPrepHostStartGamePayload;
};

template<> struct PartyPrepPayloadTraits<PartyPrepPlayerInformationPayload> {
  static const PartyPrepPayload enum_value = PartyPrepPayload_PartyPrepPlayerInformationPayload;
};

bool VerifyPartyPrepPayload(::flatbuffers::Verifier &verifier, const void *obj, PartyPrepPayload type);
bool VerifyPartyPrepPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum MessageType : int8_t {
  MessageType_Host = 0,
  MessageType_Join = 1,
  MessageType_Leaderboard = 2,
  MessageType_MiniGame = 3,
  MessageType_PartyPrep = 4,
  MessageType_MIN = MessageType_Host,
  MessageType_MAX = MessageType_PartyPrep
};

inline const MessageType (&EnumValuesMessageType())[5] {
  static const MessageType values[] = {
    MessageType_Host,
    MessageType_Join,
    MessageType_Leaderboard,
    MessageType_MiniGame,
    MessageType_PartyPrep
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[6] = {
    "Host",
    "Join",
    "Leaderboard",
    "MiniGame",
    "PartyPrep",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType_Host, MessageType_PartyPrep)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum Payload : uint8_t {
  Payload_NONE = 0,
  Payload_HostPayloadType = 1,
  Payload_JoinPayloadType = 2,
  Payload_LeaderboardPayloadType = 3,
  Payload_MiniGamePayloadType = 4,
  Payload_PartyPrepPayloadType = 5,
  Payload_MIN = Payload_NONE,
  Payload_MAX = Payload_PartyPrepPayloadType
};

inline const Payload (&EnumValuesPayload())[6] {
  static const Payload values[] = {
    Payload_NONE,
    Payload_HostPayloadType,
    Payload_JoinPayloadType,
    Payload_LeaderboardPayloadType,
    Payload_MiniGamePayloadType,
    Payload_PartyPrepPayloadType
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[7] = {
    "NONE",
    "HostPayloadType",
    "JoinPayloadType",
    "LeaderboardPayloadType",
    "MiniGamePayloadType",
    "PartyPrepPayloadType",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  if (::flatbuffers::IsOutRange(e, Payload_NONE, Payload_PartyPrepPayloadType)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload_NONE;
};

template<> struct PayloadTraits<HostPayloadType> {
  static const Payload enum_value = Payload_HostPayloadType;
};

template<> struct PayloadTraits<JoinPayloadType> {
  static const Payload enum_value = Payload_JoinPayloadType;
};

template<> struct PayloadTraits<LeaderboardPayloadType> {
  static const Payload enum_value = Payload_LeaderboardPayloadType;
};

template<> struct PayloadTraits<MiniGamePayloadType> {
  static const Payload enum_value = Payload_MiniGamePayloadType;
};

template<> struct PayloadTraits<PartyPrepPayloadType> {
  static const Payload enum_value = Payload_PartyPrepPayloadType;
};

bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct HostPayloadType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HostPayloadTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOM_ID = 4
  };
  int64_t room_id() const {
    return GetField<int64_t>(VT_ROOM_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ROOM_ID, 8) &&
           verifier.EndTable();
  }
};

struct HostPayloadTypeBuilder {
  typedef HostPayloadType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_room_id(int64_t room_id) {
    fbb_.AddElement<int64_t>(HostPayloadType::VT_ROOM_ID, room_id, 0);
  }
  explicit HostPayloadTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HostPayloadType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HostPayloadType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HostPayloadType> CreateHostPayloadType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t room_id = 0) {
  HostPayloadTypeBuilder builder_(_fbb);
  builder_.add_room_id(room_id);
  return builder_.Finish();
}

struct JoinPayloadType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinPayloadTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
};

struct JoinPayloadTypeBuilder {
  typedef JoinPayloadType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(JoinPayloadType::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit JoinPayloadTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinPayloadType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinPayloadType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinPayloadType> CreateJoinPayloadType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  JoinPayloadTypeBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct FBLeaderboardPlayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FBLeaderboardPlayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SCORE = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint64_t score() const {
    return GetField<uint64_t>(VT_SCORE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_SCORE, 8) &&
           verifier.EndTable();
  }
};

struct FBLeaderboardPlayerBuilder {
  typedef FBLeaderboardPlayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FBLeaderboardPlayer::VT_NAME, name);
  }
  void add_score(uint64_t score) {
    fbb_.AddElement<uint64_t>(FBLeaderboardPlayer::VT_SCORE, score, 0);
  }
  explicit FBLeaderboardPlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FBLeaderboardPlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FBLeaderboardPlayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FBLeaderboardPlayer> CreateFBLeaderboardPlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t score = 0) {
  FBLeaderboardPlayerBuilder builder_(_fbb);
  builder_.add_score(score);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FBLeaderboardPlayer> CreateFBLeaderboardPlayerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t score = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateFBLeaderboardPlayer(
      _fbb,
      name__,
      score);
}

struct LeaderboardInformationPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeaderboardInformationPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEADERBOARD_TIME_LEFT = 4,
    VT_LEADERBOARD = 6
  };
  uint64_t leaderboard_time_left() const {
    return GetField<uint64_t>(VT_LEADERBOARD_TIME_LEFT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBLeaderboardPlayer>> *leaderboard() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBLeaderboardPlayer>> *>(VT_LEADERBOARD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LEADERBOARD_TIME_LEFT, 8) &&
           VerifyOffset(verifier, VT_LEADERBOARD) &&
           verifier.VerifyVector(leaderboard()) &&
           verifier.VerifyVectorOfTables(leaderboard()) &&
           verifier.EndTable();
  }
};

struct LeaderboardInformationPayloadBuilder {
  typedef LeaderboardInformationPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_leaderboard_time_left(uint64_t leaderboard_time_left) {
    fbb_.AddElement<uint64_t>(LeaderboardInformationPayload::VT_LEADERBOARD_TIME_LEFT, leaderboard_time_left, 0);
  }
  void add_leaderboard(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBLeaderboardPlayer>>> leaderboard) {
    fbb_.AddOffset(LeaderboardInformationPayload::VT_LEADERBOARD, leaderboard);
  }
  explicit LeaderboardInformationPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeaderboardInformationPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeaderboardInformationPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeaderboardInformationPayload> CreateLeaderboardInformationPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t leaderboard_time_left = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBLeaderboardPlayer>>> leaderboard = 0) {
  LeaderboardInformationPayloadBuilder builder_(_fbb);
  builder_.add_leaderboard_time_left(leaderboard_time_left);
  builder_.add_leaderboard(leaderboard);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LeaderboardInformationPayload> CreateLeaderboardInformationPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t leaderboard_time_left = 0,
    const std::vector<::flatbuffers::Offset<FBLeaderboardPlayer>> *leaderboard = nullptr) {
  auto leaderboard__ = leaderboard ? _fbb.CreateVector<::flatbuffers::Offset<FBLeaderboardPlayer>>(*leaderboard) : 0;
  return CreateLeaderboardInformationPayload(
      _fbb,
      leaderboard_time_left,
      leaderboard__);
}

struct LeaderboardHostSkipPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeaderboardHostSkipPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKIP = 4
  };
  bool skip() const {
    return GetField<uint8_t>(VT_SKIP, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SKIP, 1) &&
           verifier.EndTable();
  }
};

struct LeaderboardHostSkipPayloadBuilder {
  typedef LeaderboardHostSkipPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_skip(bool skip) {
    fbb_.AddElement<uint8_t>(LeaderboardHostSkipPayload::VT_SKIP, static_cast<uint8_t>(skip), 0);
  }
  explicit LeaderboardHostSkipPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeaderboardHostSkipPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeaderboardHostSkipPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeaderboardHostSkipPayload> CreateLeaderboardHostSkipPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool skip = false) {
  LeaderboardHostSkipPayloadBuilder builder_(_fbb);
  builder_.add_skip(skip);
  return builder_.Finish();
}

struct LeaderboardPayloadType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LeaderboardPayloadTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEADERBOARDTYPE = 4,
    VT_LEADERBOARDPAYLOAD_TYPE = 6,
    VT_LEADERBOARDPAYLOAD = 8
  };
  LeaderboardType leaderboardtype() const {
    return static_cast<LeaderboardType>(GetField<int8_t>(VT_LEADERBOARDTYPE, 0));
  }
  LeaderboardPayload leaderboardpayload_type() const {
    return static_cast<LeaderboardPayload>(GetField<uint8_t>(VT_LEADERBOARDPAYLOAD_TYPE, 0));
  }
  const void *leaderboardpayload() const {
    return GetPointer<const void *>(VT_LEADERBOARDPAYLOAD);
  }
  template<typename T> const T *leaderboardpayload_as() const;
  const LeaderboardInformationPayload *leaderboardpayload_as_LeaderboardInformationPayload() const {
    return leaderboardpayload_type() == LeaderboardPayload_LeaderboardInformationPayload ? static_cast<const LeaderboardInformationPayload *>(leaderboardpayload()) : nullptr;
  }
  const LeaderboardHostSkipPayload *leaderboardpayload_as_LeaderboardHostSkipPayload() const {
    return leaderboardpayload_type() == LeaderboardPayload_LeaderboardHostSkipPayload ? static_cast<const LeaderboardHostSkipPayload *>(leaderboardpayload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LEADERBOARDTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_LEADERBOARDPAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_LEADERBOARDPAYLOAD) &&
           VerifyLeaderboardPayload(verifier, leaderboardpayload(), leaderboardpayload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const LeaderboardInformationPayload *LeaderboardPayloadType::leaderboardpayload_as<LeaderboardInformationPayload>() const {
  return leaderboardpayload_as_LeaderboardInformationPayload();
}

template<> inline const LeaderboardHostSkipPayload *LeaderboardPayloadType::leaderboardpayload_as<LeaderboardHostSkipPayload>() const {
  return leaderboardpayload_as_LeaderboardHostSkipPayload();
}

struct LeaderboardPayloadTypeBuilder {
  typedef LeaderboardPayloadType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_leaderboardtype(LeaderboardType leaderboardtype) {
    fbb_.AddElement<int8_t>(LeaderboardPayloadType::VT_LEADERBOARDTYPE, static_cast<int8_t>(leaderboardtype), 0);
  }
  void add_leaderboardpayload_type(LeaderboardPayload leaderboardpayload_type) {
    fbb_.AddElement<uint8_t>(LeaderboardPayloadType::VT_LEADERBOARDPAYLOAD_TYPE, static_cast<uint8_t>(leaderboardpayload_type), 0);
  }
  void add_leaderboardpayload(::flatbuffers::Offset<void> leaderboardpayload) {
    fbb_.AddOffset(LeaderboardPayloadType::VT_LEADERBOARDPAYLOAD, leaderboardpayload);
  }
  explicit LeaderboardPayloadTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LeaderboardPayloadType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LeaderboardPayloadType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LeaderboardPayloadType> CreateLeaderboardPayloadType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LeaderboardType leaderboardtype = LeaderboardType_LeaderboardInformation,
    LeaderboardPayload leaderboardpayload_type = LeaderboardPayload_NONE,
    ::flatbuffers::Offset<void> leaderboardpayload = 0) {
  LeaderboardPayloadTypeBuilder builder_(_fbb);
  builder_.add_leaderboardpayload(leaderboardpayload);
  builder_.add_leaderboardpayload_type(leaderboardpayload_type);
  builder_.add_leaderboardtype(leaderboardtype);
  return builder_.Finish();
}

struct PlayerBailout FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerBailoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6,
    VT_TIME = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t time() const {
    return GetField<uint32_t>(VT_TIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_TIME, 4) &&
           verifier.EndTable();
  }
};

struct PlayerBailoutBuilder {
  typedef PlayerBailout Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PlayerBailout::VT_NAME, name);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(PlayerBailout::VT_VALUE, value, 0);
  }
  void add_time(uint32_t time) {
    fbb_.AddElement<uint32_t>(PlayerBailout::VT_TIME, time, 0);
  }
  explicit PlayerBailoutBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerBailout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerBailout>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerBailout> CreatePlayerBailout(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t value = 0,
    uint32_t time = 0) {
  PlayerBailoutBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerBailout> CreatePlayerBailoutDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t value = 0,
    uint32_t time = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreatePlayerBailout(
      _fbb,
      name__,
      value,
      time);
}

struct BusinessBailoutHostPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BusinessBailoutHostPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_TIME = 6,
    VT_BAILED_PLAYERS = 8
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  uint32_t time() const {
    return GetField<uint32_t>(VT_TIME, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<PlayerBailout>> *bailed_players() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PlayerBailout>> *>(VT_BAILED_PLAYERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_TIME, 4) &&
           VerifyOffset(verifier, VT_BAILED_PLAYERS) &&
           verifier.VerifyVector(bailed_players()) &&
           verifier.VerifyVectorOfTables(bailed_players()) &&
           verifier.EndTable();
  }
};

struct BusinessBailoutHostPayloadBuilder {
  typedef BusinessBailoutHostPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(BusinessBailoutHostPayload::VT_VALUE, value, 0);
  }
  void add_time(uint32_t time) {
    fbb_.AddElement<uint32_t>(BusinessBailoutHostPayload::VT_TIME, time, 0);
  }
  void add_bailed_players(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PlayerBailout>>> bailed_players) {
    fbb_.AddOffset(BusinessBailoutHostPayload::VT_BAILED_PLAYERS, bailed_players);
  }
  explicit BusinessBailoutHostPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BusinessBailoutHostPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BusinessBailoutHostPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BusinessBailoutHostPayload> CreateBusinessBailoutHostPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t time = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PlayerBailout>>> bailed_players = 0) {
  BusinessBailoutHostPayloadBuilder builder_(_fbb);
  builder_.add_bailed_players(bailed_players);
  builder_.add_time(time);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BusinessBailoutHostPayload> CreateBusinessBailoutHostPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    uint32_t time = 0,
    const std::vector<::flatbuffers::Offset<PlayerBailout>> *bailed_players = nullptr) {
  auto bailed_players__ = bailed_players ? _fbb.CreateVector<::flatbuffers::Offset<PlayerBailout>>(*bailed_players) : 0;
  return CreateBusinessBailoutHostPayload(
      _fbb,
      value,
      time,
      bailed_players__);
}

struct BusinessBailoutPlayerInputPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BusinessBailoutPlayerInputPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCK = 4
  };
  bool lock() const {
    return GetField<uint8_t>(VT_LOCK, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_LOCK, 1) &&
           verifier.EndTable();
  }
};

struct BusinessBailoutPlayerInputPayloadBuilder {
  typedef BusinessBailoutPlayerInputPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lock(bool lock) {
    fbb_.AddElement<uint8_t>(BusinessBailoutPlayerInputPayload::VT_LOCK, static_cast<uint8_t>(lock), 0);
  }
  explicit BusinessBailoutPlayerInputPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BusinessBailoutPlayerInputPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BusinessBailoutPlayerInputPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BusinessBailoutPlayerInputPayload> CreateBusinessBailoutPlayerInputPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool lock = false) {
  BusinessBailoutPlayerInputPayloadBuilder builder_(_fbb);
  builder_.add_lock(lock);
  return builder_.Finish();
}

struct BusinessBailoutPlayerPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BusinessBailoutPlayerPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_LOCKED = 6
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool locked() const {
    return GetField<uint8_t>(VT_LOCKED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<uint8_t>(verifier, VT_LOCKED, 1) &&
           verifier.EndTable();
  }
};

struct BusinessBailoutPlayerPayloadBuilder {
  typedef BusinessBailoutPlayerPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(BusinessBailoutPlayerPayload::VT_VALUE, value, 0);
  }
  void add_locked(bool locked) {
    fbb_.AddElement<uint8_t>(BusinessBailoutPlayerPayload::VT_LOCKED, static_cast<uint8_t>(locked), 0);
  }
  explicit BusinessBailoutPlayerPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BusinessBailoutPlayerPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BusinessBailoutPlayerPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BusinessBailoutPlayerPayload> CreateBusinessBailoutPlayerPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    bool locked = false) {
  BusinessBailoutPlayerPayloadBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_locked(locked);
  return builder_.Finish();
}

struct BusinessBailoutResultPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BusinessBailoutResultPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBBusinessBailoutResultPair>> *results() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBBusinessBailoutResultPair>> *>(VT_RESULTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESULTS) &&
           verifier.VerifyVector(results()) &&
           verifier.VerifyVectorOfTables(results()) &&
           verifier.EndTable();
  }
};

struct BusinessBailoutResultPayloadBuilder {
  typedef BusinessBailoutResultPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_results(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBBusinessBailoutResultPair>>> results) {
    fbb_.AddOffset(BusinessBailoutResultPayload::VT_RESULTS, results);
  }
  explicit BusinessBailoutResultPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BusinessBailoutResultPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BusinessBailoutResultPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BusinessBailoutResultPayload> CreateBusinessBailoutResultPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBBusinessBailoutResultPair>>> results = 0) {
  BusinessBailoutResultPayloadBuilder builder_(_fbb);
  builder_.add_results(results);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BusinessBailoutResultPayload> CreateBusinessBailoutResultPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<FBBusinessBailoutResultPair>> *results = nullptr) {
  auto results__ = results ? _fbb.CreateVector<::flatbuffers::Offset<FBBusinessBailoutResultPair>>(*results) : 0;
  return CreateBusinessBailoutResultPayload(
      _fbb,
      results__);
}

struct FBBusinessBailoutResultPair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FBBusinessBailoutResultPairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6,
    VT_TIME = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  int32_t time() const {
    return GetField<int32_t>(VT_TIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           VerifyField<int32_t>(verifier, VT_TIME, 4) &&
           verifier.EndTable();
  }
};

struct FBBusinessBailoutResultPairBuilder {
  typedef FBBusinessBailoutResultPair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FBBusinessBailoutResultPair::VT_NAME, name);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(FBBusinessBailoutResultPair::VT_VALUE, value, 0);
  }
  void add_time(int32_t time) {
    fbb_.AddElement<int32_t>(FBBusinessBailoutResultPair::VT_TIME, time, 0);
  }
  explicit FBBusinessBailoutResultPairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FBBusinessBailoutResultPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FBBusinessBailoutResultPair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FBBusinessBailoutResultPair> CreateFBBusinessBailoutResultPair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t value = 0,
    int32_t time = 0) {
  FBBusinessBailoutResultPairBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FBBusinessBailoutResultPair> CreateFBBusinessBailoutResultPairDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t value = 0,
    int32_t time = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateFBBusinessBailoutResultPair(
      _fbb,
      name__,
      value,
      time);
}

struct CrazyCountingHostEntitiesPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CrazyCountingHostEntitiesPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_LEFT = 4,
    VT_ENTITIES = 6,
    VT_SUBMITTED = 8
  };
  uint64_t time_left() const {
    return GetField<uint64_t>(VT_TIME_LEFT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBCrazyCountingEntity>> *entities() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBCrazyCountingEntity>> *>(VT_ENTITIES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *submitted() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SUBMITTED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME_LEFT, 8) &&
           VerifyOffset(verifier, VT_ENTITIES) &&
           verifier.VerifyVector(entities()) &&
           verifier.VerifyVectorOfTables(entities()) &&
           VerifyOffset(verifier, VT_SUBMITTED) &&
           verifier.VerifyVector(submitted()) &&
           verifier.VerifyVectorOfStrings(submitted()) &&
           verifier.EndTable();
  }
};

struct CrazyCountingHostEntitiesPayloadBuilder {
  typedef CrazyCountingHostEntitiesPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time_left(uint64_t time_left) {
    fbb_.AddElement<uint64_t>(CrazyCountingHostEntitiesPayload::VT_TIME_LEFT, time_left, 0);
  }
  void add_entities(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBCrazyCountingEntity>>> entities) {
    fbb_.AddOffset(CrazyCountingHostEntitiesPayload::VT_ENTITIES, entities);
  }
  void add_submitted(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> submitted) {
    fbb_.AddOffset(CrazyCountingHostEntitiesPayload::VT_SUBMITTED, submitted);
  }
  explicit CrazyCountingHostEntitiesPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CrazyCountingHostEntitiesPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CrazyCountingHostEntitiesPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CrazyCountingHostEntitiesPayload> CreateCrazyCountingHostEntitiesPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time_left = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBCrazyCountingEntity>>> entities = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> submitted = 0) {
  CrazyCountingHostEntitiesPayloadBuilder builder_(_fbb);
  builder_.add_time_left(time_left);
  builder_.add_submitted(submitted);
  builder_.add_entities(entities);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CrazyCountingHostEntitiesPayload> CreateCrazyCountingHostEntitiesPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time_left = 0,
    const std::vector<::flatbuffers::Offset<FBCrazyCountingEntity>> *entities = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *submitted = nullptr) {
  auto entities__ = entities ? _fbb.CreateVector<::flatbuffers::Offset<FBCrazyCountingEntity>>(*entities) : 0;
  auto submitted__ = submitted ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*submitted) : 0;
  return CreateCrazyCountingHostEntitiesPayload(
      _fbb,
      time_left,
      entities__,
      submitted__);
}

struct FBCrazyCountingEntity FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FBCrazyCountingEntityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_POS = 4,
    VT_Y_POS = 6
  };
  float x_pos() const {
    return GetField<float>(VT_X_POS, 0.0f);
  }
  float y_pos() const {
    return GetField<float>(VT_Y_POS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X_POS, 4) &&
           VerifyField<float>(verifier, VT_Y_POS, 4) &&
           verifier.EndTable();
  }
};

struct FBCrazyCountingEntityBuilder {
  typedef FBCrazyCountingEntity Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x_pos(float x_pos) {
    fbb_.AddElement<float>(FBCrazyCountingEntity::VT_X_POS, x_pos, 0.0f);
  }
  void add_y_pos(float y_pos) {
    fbb_.AddElement<float>(FBCrazyCountingEntity::VT_Y_POS, y_pos, 0.0f);
  }
  explicit FBCrazyCountingEntityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FBCrazyCountingEntity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FBCrazyCountingEntity>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FBCrazyCountingEntity> CreateFBCrazyCountingEntity(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x_pos = 0.0f,
    float y_pos = 0.0f) {
  FBCrazyCountingEntityBuilder builder_(_fbb);
  builder_.add_y_pos(y_pos);
  builder_.add_x_pos(x_pos);
  return builder_.Finish();
}

struct CrazyCountingPlayerInputPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CrazyCountingPlayerInputPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_TYPE = 4
  };
  Input input_type() const {
    return static_cast<Input>(GetField<int8_t>(VT_INPUT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_INPUT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct CrazyCountingPlayerInputPayloadBuilder {
  typedef CrazyCountingPlayerInputPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_input_type(Input input_type) {
    fbb_.AddElement<int8_t>(CrazyCountingPlayerInputPayload::VT_INPUT_TYPE, static_cast<int8_t>(input_type), 0);
  }
  explicit CrazyCountingPlayerInputPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CrazyCountingPlayerInputPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CrazyCountingPlayerInputPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CrazyCountingPlayerInputPayload> CreateCrazyCountingPlayerInputPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Input input_type = Input_Increase) {
  CrazyCountingPlayerInputPayloadBuilder builder_(_fbb);
  builder_.add_input_type(input_type);
  return builder_.Finish();
}

struct CrazyCountingPlayerUpdatePayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CrazyCountingPlayerUpdatePayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_INT = 4,
    VT_TIME_LEFT = 6,
    VT_SUBMITTED = 8
  };
  int16_t new_int() const {
    return GetField<int16_t>(VT_NEW_INT, 0);
  }
  uint64_t time_left() const {
    return GetField<uint64_t>(VT_TIME_LEFT, 0);
  }
  bool submitted() const {
    return GetField<uint8_t>(VT_SUBMITTED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_NEW_INT, 2) &&
           VerifyField<uint64_t>(verifier, VT_TIME_LEFT, 8) &&
           VerifyField<uint8_t>(verifier, VT_SUBMITTED, 1) &&
           verifier.EndTable();
  }
};

struct CrazyCountingPlayerUpdatePayloadBuilder {
  typedef CrazyCountingPlayerUpdatePayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_new_int(int16_t new_int) {
    fbb_.AddElement<int16_t>(CrazyCountingPlayerUpdatePayload::VT_NEW_INT, new_int, 0);
  }
  void add_time_left(uint64_t time_left) {
    fbb_.AddElement<uint64_t>(CrazyCountingPlayerUpdatePayload::VT_TIME_LEFT, time_left, 0);
  }
  void add_submitted(bool submitted) {
    fbb_.AddElement<uint8_t>(CrazyCountingPlayerUpdatePayload::VT_SUBMITTED, static_cast<uint8_t>(submitted), 0);
  }
  explicit CrazyCountingPlayerUpdatePayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CrazyCountingPlayerUpdatePayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CrazyCountingPlayerUpdatePayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CrazyCountingPlayerUpdatePayload> CreateCrazyCountingPlayerUpdatePayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t new_int = 0,
    uint64_t time_left = 0,
    bool submitted = false) {
  CrazyCountingPlayerUpdatePayloadBuilder builder_(_fbb);
  builder_.add_time_left(time_left);
  builder_.add_new_int(new_int);
  builder_.add_submitted(submitted);
  return builder_.Finish();
}

struct CrazyCountingResultPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CrazyCountingResultPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CORRECT_ANSWER = 4,
    VT_RESULTS = 6
  };
  int16_t correct_answer() const {
    return GetField<int16_t>(VT_CORRECT_ANSWER, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBCrazyCountingResultPair>> *results() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBCrazyCountingResultPair>> *>(VT_RESULTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CORRECT_ANSWER, 2) &&
           VerifyOffset(verifier, VT_RESULTS) &&
           verifier.VerifyVector(results()) &&
           verifier.VerifyVectorOfTables(results()) &&
           verifier.EndTable();
  }
};

struct CrazyCountingResultPayloadBuilder {
  typedef CrazyCountingResultPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_correct_answer(int16_t correct_answer) {
    fbb_.AddElement<int16_t>(CrazyCountingResultPayload::VT_CORRECT_ANSWER, correct_answer, 0);
  }
  void add_results(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBCrazyCountingResultPair>>> results) {
    fbb_.AddOffset(CrazyCountingResultPayload::VT_RESULTS, results);
  }
  explicit CrazyCountingResultPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CrazyCountingResultPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CrazyCountingResultPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CrazyCountingResultPayload> CreateCrazyCountingResultPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t correct_answer = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBCrazyCountingResultPair>>> results = 0) {
  CrazyCountingResultPayloadBuilder builder_(_fbb);
  builder_.add_results(results);
  builder_.add_correct_answer(correct_answer);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CrazyCountingResultPayload> CreateCrazyCountingResultPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t correct_answer = 0,
    const std::vector<::flatbuffers::Offset<FBCrazyCountingResultPair>> *results = nullptr) {
  auto results__ = results ? _fbb.CreateVector<::flatbuffers::Offset<FBCrazyCountingResultPair>>(*results) : 0;
  return CreateCrazyCountingResultPayload(
      _fbb,
      correct_answer,
      results__);
}

struct FBCrazyCountingResultPair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FBCrazyCountingResultPairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_GUESS = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int16_t guess() const {
    return GetField<int16_t>(VT_GUESS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_GUESS, 2) &&
           verifier.EndTable();
  }
};

struct FBCrazyCountingResultPairBuilder {
  typedef FBCrazyCountingResultPair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FBCrazyCountingResultPair::VT_NAME, name);
  }
  void add_guess(int16_t guess) {
    fbb_.AddElement<int16_t>(FBCrazyCountingResultPair::VT_GUESS, guess, 0);
  }
  explicit FBCrazyCountingResultPairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FBCrazyCountingResultPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FBCrazyCountingResultPair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FBCrazyCountingResultPair> CreateFBCrazyCountingResultPair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int16_t guess = 0) {
  FBCrazyCountingResultPairBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_guess(guess);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FBCrazyCountingResultPair> CreateFBCrazyCountingResultPairDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t guess = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateFBCrazyCountingResultPair(
      _fbb,
      name__,
      guess);
}

struct MemoryMixerGridRow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MemoryMixerGridRowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROW = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<MemoryMixerGridCell>> *row() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MemoryMixerGridCell>> *>(VT_ROW);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROW) &&
           verifier.VerifyVector(row()) &&
           verifier.VerifyVectorOfTables(row()) &&
           verifier.EndTable();
  }
};

struct MemoryMixerGridRowBuilder {
  typedef MemoryMixerGridRow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_row(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MemoryMixerGridCell>>> row) {
    fbb_.AddOffset(MemoryMixerGridRow::VT_ROW, row);
  }
  explicit MemoryMixerGridRowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MemoryMixerGridRow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MemoryMixerGridRow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MemoryMixerGridRow> CreateMemoryMixerGridRow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MemoryMixerGridCell>>> row = 0) {
  MemoryMixerGridRowBuilder builder_(_fbb);
  builder_.add_row(row);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MemoryMixerGridRow> CreateMemoryMixerGridRowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<MemoryMixerGridCell>> *row = nullptr) {
  auto row__ = row ? _fbb.CreateVector<::flatbuffers::Offset<MemoryMixerGridCell>>(*row) : 0;
  return CreateMemoryMixerGridRow(
      _fbb,
      row__);
}

struct MemoryMixerGridCell FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MemoryMixerGridCellBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ICON = 4,
    VT_PLAYERS_ON_CARD = 6,
    VT_IS_HIGHLIGHTED = 8
  };
  MemoryMixerIconType icon() const {
    return static_cast<MemoryMixerIconType>(GetField<int8_t>(VT_ICON, 0));
  }
  int16_t players_on_card() const {
    return GetField<int16_t>(VT_PLAYERS_ON_CARD, 0);
  }
  bool is_highlighted() const {
    return GetField<uint8_t>(VT_IS_HIGHLIGHTED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ICON, 1) &&
           VerifyField<int16_t>(verifier, VT_PLAYERS_ON_CARD, 2) &&
           VerifyField<uint8_t>(verifier, VT_IS_HIGHLIGHTED, 1) &&
           verifier.EndTable();
  }
};

struct MemoryMixerGridCellBuilder {
  typedef MemoryMixerGridCell Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_icon(MemoryMixerIconType icon) {
    fbb_.AddElement<int8_t>(MemoryMixerGridCell::VT_ICON, static_cast<int8_t>(icon), 0);
  }
  void add_players_on_card(int16_t players_on_card) {
    fbb_.AddElement<int16_t>(MemoryMixerGridCell::VT_PLAYERS_ON_CARD, players_on_card, 0);
  }
  void add_is_highlighted(bool is_highlighted) {
    fbb_.AddElement<uint8_t>(MemoryMixerGridCell::VT_IS_HIGHLIGHTED, static_cast<uint8_t>(is_highlighted), 0);
  }
  explicit MemoryMixerGridCellBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MemoryMixerGridCell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MemoryMixerGridCell>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MemoryMixerGridCell> CreateMemoryMixerGridCell(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MemoryMixerIconType icon = MemoryMixerIconType_BALLOON,
    int16_t players_on_card = 0,
    bool is_highlighted = false) {
  MemoryMixerGridCellBuilder builder_(_fbb);
  builder_.add_players_on_card(players_on_card);
  builder_.add_is_highlighted(is_highlighted);
  builder_.add_icon(icon);
  return builder_.Finish();
}

struct MemoryMixerGridPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MemoryMixerGridPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_LEFT = 4,
    VT_MAX_ON_CARD = 6,
    VT_PHASE = 8,
    VT_ROUND = 10,
    VT_PLAYERS_LEFT = 12,
    VT_NAMES = 14,
    VT_GRID = 16
  };
  uint64_t time_left() const {
    return GetField<uint64_t>(VT_TIME_LEFT, 0);
  }
  int16_t max_on_card() const {
    return GetField<int16_t>(VT_MAX_ON_CARD, 0);
  }
  int16_t phase() const {
    return GetField<int16_t>(VT_PHASE, 0);
  }
  int16_t round() const {
    return GetField<int16_t>(VT_ROUND, 0);
  }
  int16_t players_left() const {
    return GetField<int16_t>(VT_PLAYERS_LEFT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NAMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MemoryMixerGridRow>> *grid() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MemoryMixerGridRow>> *>(VT_GRID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME_LEFT, 8) &&
           VerifyField<int16_t>(verifier, VT_MAX_ON_CARD, 2) &&
           VerifyField<int16_t>(verifier, VT_PHASE, 2) &&
           VerifyField<int16_t>(verifier, VT_ROUND, 2) &&
           VerifyField<int16_t>(verifier, VT_PLAYERS_LEFT, 2) &&
           VerifyOffset(verifier, VT_NAMES) &&
           verifier.VerifyVector(names()) &&
           verifier.VerifyVectorOfStrings(names()) &&
           VerifyOffset(verifier, VT_GRID) &&
           verifier.VerifyVector(grid()) &&
           verifier.VerifyVectorOfTables(grid()) &&
           verifier.EndTable();
  }
};

struct MemoryMixerGridPayloadBuilder {
  typedef MemoryMixerGridPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time_left(uint64_t time_left) {
    fbb_.AddElement<uint64_t>(MemoryMixerGridPayload::VT_TIME_LEFT, time_left, 0);
  }
  void add_max_on_card(int16_t max_on_card) {
    fbb_.AddElement<int16_t>(MemoryMixerGridPayload::VT_MAX_ON_CARD, max_on_card, 0);
  }
  void add_phase(int16_t phase) {
    fbb_.AddElement<int16_t>(MemoryMixerGridPayload::VT_PHASE, phase, 0);
  }
  void add_round(int16_t round) {
    fbb_.AddElement<int16_t>(MemoryMixerGridPayload::VT_ROUND, round, 0);
  }
  void add_players_left(int16_t players_left) {
    fbb_.AddElement<int16_t>(MemoryMixerGridPayload::VT_PLAYERS_LEFT, players_left, 0);
  }
  void add_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> names) {
    fbb_.AddOffset(MemoryMixerGridPayload::VT_NAMES, names);
  }
  void add_grid(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MemoryMixerGridRow>>> grid) {
    fbb_.AddOffset(MemoryMixerGridPayload::VT_GRID, grid);
  }
  explicit MemoryMixerGridPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MemoryMixerGridPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MemoryMixerGridPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MemoryMixerGridPayload> CreateMemoryMixerGridPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time_left = 0,
    int16_t max_on_card = 0,
    int16_t phase = 0,
    int16_t round = 0,
    int16_t players_left = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> names = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MemoryMixerGridRow>>> grid = 0) {
  MemoryMixerGridPayloadBuilder builder_(_fbb);
  builder_.add_time_left(time_left);
  builder_.add_grid(grid);
  builder_.add_names(names);
  builder_.add_players_left(players_left);
  builder_.add_round(round);
  builder_.add_phase(phase);
  builder_.add_max_on_card(max_on_card);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MemoryMixerGridPayload> CreateMemoryMixerGridPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t time_left = 0,
    int16_t max_on_card = 0,
    int16_t phase = 0,
    int16_t round = 0,
    int16_t players_left = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *names = nullptr,
    const std::vector<::flatbuffers::Offset<MemoryMixerGridRow>> *grid = nullptr) {
  auto names__ = names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*names) : 0;
  auto grid__ = grid ? _fbb.CreateVector<::flatbuffers::Offset<MemoryMixerGridRow>>(*grid) : 0;
  return CreateMemoryMixerGridPayload(
      _fbb,
      time_left,
      max_on_card,
      phase,
      round,
      players_left,
      names__,
      grid__);
}

struct MemoryMixerPlayerInputPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MemoryMixerPlayerInputPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  int16_t x() const {
    return GetField<int16_t>(VT_X, 0);
  }
  int16_t y() const {
    return GetField<int16_t>(VT_Y, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_X, 2) &&
           VerifyField<int16_t>(verifier, VT_Y, 2) &&
           verifier.EndTable();
  }
};

struct MemoryMixerPlayerInputPayloadBuilder {
  typedef MemoryMixerPlayerInputPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(int16_t x) {
    fbb_.AddElement<int16_t>(MemoryMixerPlayerInputPayload::VT_X, x, 0);
  }
  void add_y(int16_t y) {
    fbb_.AddElement<int16_t>(MemoryMixerPlayerInputPayload::VT_Y, y, 0);
  }
  explicit MemoryMixerPlayerInputPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MemoryMixerPlayerInputPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MemoryMixerPlayerInputPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MemoryMixerPlayerInputPayload> CreateMemoryMixerPlayerInputPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t x = 0,
    int16_t y = 0) {
  MemoryMixerPlayerInputPayloadBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct MemoryMixerPlayerSubmittedPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MemoryMixerPlayerSubmittedPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBMITTED = 4,
    VT_X = 6,
    VT_Y = 8
  };
  bool submitted() const {
    return GetField<uint8_t>(VT_SUBMITTED, 0) != 0;
  }
  int16_t x() const {
    return GetField<int16_t>(VT_X, 0);
  }
  int16_t y() const {
    return GetField<int16_t>(VT_Y, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUBMITTED, 1) &&
           VerifyField<int16_t>(verifier, VT_X, 2) &&
           VerifyField<int16_t>(verifier, VT_Y, 2) &&
           verifier.EndTable();
  }
};

struct MemoryMixerPlayerSubmittedPayloadBuilder {
  typedef MemoryMixerPlayerSubmittedPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_submitted(bool submitted) {
    fbb_.AddElement<uint8_t>(MemoryMixerPlayerSubmittedPayload::VT_SUBMITTED, static_cast<uint8_t>(submitted), 0);
  }
  void add_x(int16_t x) {
    fbb_.AddElement<int16_t>(MemoryMixerPlayerSubmittedPayload::VT_X, x, 0);
  }
  void add_y(int16_t y) {
    fbb_.AddElement<int16_t>(MemoryMixerPlayerSubmittedPayload::VT_Y, y, 0);
  }
  explicit MemoryMixerPlayerSubmittedPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MemoryMixerPlayerSubmittedPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MemoryMixerPlayerSubmittedPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MemoryMixerPlayerSubmittedPayload> CreateMemoryMixerPlayerSubmittedPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool submitted = false,
    int16_t x = 0,
    int16_t y = 0) {
  MemoryMixerPlayerSubmittedPayloadBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_submitted(submitted);
  return builder_.Finish();
}

struct MemoryMixerResultPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MemoryMixerResultPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUND = 4,
    VT_MINIGAME_RESULTS = 6
  };
  int16_t round() const {
    return GetField<int16_t>(VT_ROUND, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBMemoryMixerResultPair>> *minigame_results() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBMemoryMixerResultPair>> *>(VT_MINIGAME_RESULTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ROUND, 2) &&
           VerifyOffset(verifier, VT_MINIGAME_RESULTS) &&
           verifier.VerifyVector(minigame_results()) &&
           verifier.VerifyVectorOfTables(minigame_results()) &&
           verifier.EndTable();
  }
};

struct MemoryMixerResultPayloadBuilder {
  typedef MemoryMixerResultPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_round(int16_t round) {
    fbb_.AddElement<int16_t>(MemoryMixerResultPayload::VT_ROUND, round, 0);
  }
  void add_minigame_results(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBMemoryMixerResultPair>>> minigame_results) {
    fbb_.AddOffset(MemoryMixerResultPayload::VT_MINIGAME_RESULTS, minigame_results);
  }
  explicit MemoryMixerResultPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MemoryMixerResultPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MemoryMixerResultPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MemoryMixerResultPayload> CreateMemoryMixerResultPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t round = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBMemoryMixerResultPair>>> minigame_results = 0) {
  MemoryMixerResultPayloadBuilder builder_(_fbb);
  builder_.add_minigame_results(minigame_results);
  builder_.add_round(round);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MemoryMixerResultPayload> CreateMemoryMixerResultPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t round = 0,
    const std::vector<::flatbuffers::Offset<FBMemoryMixerResultPair>> *minigame_results = nullptr) {
  auto minigame_results__ = minigame_results ? _fbb.CreateVector<::flatbuffers::Offset<FBMemoryMixerResultPair>>(*minigame_results) : 0;
  return CreateMemoryMixerResultPayload(
      _fbb,
      round,
      minigame_results__);
}

struct FBMemoryMixerResultPair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FBMemoryMixerResultPairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLACEMENT = 4,
    VT_NAME = 6,
    VT_ROUNDS_WON = 8
  };
  int16_t placement() const {
    return GetField<int16_t>(VT_PLACEMENT, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int16_t rounds_won() const {
    return GetField<int16_t>(VT_ROUNDS_WON, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PLACEMENT, 2) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_ROUNDS_WON, 2) &&
           verifier.EndTable();
  }
};

struct FBMemoryMixerResultPairBuilder {
  typedef FBMemoryMixerResultPair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_placement(int16_t placement) {
    fbb_.AddElement<int16_t>(FBMemoryMixerResultPair::VT_PLACEMENT, placement, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FBMemoryMixerResultPair::VT_NAME, name);
  }
  void add_rounds_won(int16_t rounds_won) {
    fbb_.AddElement<int16_t>(FBMemoryMixerResultPair::VT_ROUNDS_WON, rounds_won, 0);
  }
  explicit FBMemoryMixerResultPairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FBMemoryMixerResultPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FBMemoryMixerResultPair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FBMemoryMixerResultPair> CreateFBMemoryMixerResultPair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t placement = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int16_t rounds_won = 0) {
  FBMemoryMixerResultPairBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_rounds_won(rounds_won);
  builder_.add_placement(placement);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FBMemoryMixerResultPair> CreateFBMemoryMixerResultPairDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t placement = 0,
    const char *name = nullptr,
    int16_t rounds_won = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateFBMemoryMixerResultPair(
      _fbb,
      placement,
      name__,
      rounds_won);
}

struct MemoryMixerRoundResultPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MemoryMixerRoundResultPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUND = 4,
    VT_CORRECT_NAMES = 6,
    VT_WRONG_NAMES = 8
  };
  int16_t round() const {
    return GetField<int16_t>(VT_ROUND, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *correct_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CORRECT_NAMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *wrong_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_WRONG_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ROUND, 2) &&
           VerifyOffset(verifier, VT_CORRECT_NAMES) &&
           verifier.VerifyVector(correct_names()) &&
           verifier.VerifyVectorOfStrings(correct_names()) &&
           VerifyOffset(verifier, VT_WRONG_NAMES) &&
           verifier.VerifyVector(wrong_names()) &&
           verifier.VerifyVectorOfStrings(wrong_names()) &&
           verifier.EndTable();
  }
};

struct MemoryMixerRoundResultPayloadBuilder {
  typedef MemoryMixerRoundResultPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_round(int16_t round) {
    fbb_.AddElement<int16_t>(MemoryMixerRoundResultPayload::VT_ROUND, round, 0);
  }
  void add_correct_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> correct_names) {
    fbb_.AddOffset(MemoryMixerRoundResultPayload::VT_CORRECT_NAMES, correct_names);
  }
  void add_wrong_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> wrong_names) {
    fbb_.AddOffset(MemoryMixerRoundResultPayload::VT_WRONG_NAMES, wrong_names);
  }
  explicit MemoryMixerRoundResultPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MemoryMixerRoundResultPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MemoryMixerRoundResultPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MemoryMixerRoundResultPayload> CreateMemoryMixerRoundResultPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t round = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> correct_names = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> wrong_names = 0) {
  MemoryMixerRoundResultPayloadBuilder builder_(_fbb);
  builder_.add_wrong_names(wrong_names);
  builder_.add_correct_names(correct_names);
  builder_.add_round(round);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MemoryMixerRoundResultPayload> CreateMemoryMixerRoundResultPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t round = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *correct_names = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *wrong_names = nullptr) {
  auto correct_names__ = correct_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*correct_names) : 0;
  auto wrong_names__ = wrong_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*wrong_names) : 0;
  return CreateMemoryMixerRoundResultPayload(
      _fbb,
      round,
      correct_names__,
      wrong_names__);
}

struct MiniGameIntroductionPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MiniGameIntroductionPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INSTRUCTION = 6,
    VT_TIME_LEFT = 8
  };
  const ::flatbuffers::String *Name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *Instruction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INSTRUCTION);
  }
  uint64_t time_left() const {
    return GetField<uint64_t>(VT_TIME_LEFT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(Name()) &&
           VerifyOffset(verifier, VT_INSTRUCTION) &&
           verifier.VerifyString(Instruction()) &&
           VerifyField<uint64_t>(verifier, VT_TIME_LEFT, 8) &&
           verifier.EndTable();
  }
};

struct MiniGameIntroductionPayloadBuilder {
  typedef MiniGameIntroductionPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Name(::flatbuffers::Offset<::flatbuffers::String> Name) {
    fbb_.AddOffset(MiniGameIntroductionPayload::VT_NAME, Name);
  }
  void add_Instruction(::flatbuffers::Offset<::flatbuffers::String> Instruction) {
    fbb_.AddOffset(MiniGameIntroductionPayload::VT_INSTRUCTION, Instruction);
  }
  void add_time_left(uint64_t time_left) {
    fbb_.AddElement<uint64_t>(MiniGameIntroductionPayload::VT_TIME_LEFT, time_left, 0);
  }
  explicit MiniGameIntroductionPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MiniGameIntroductionPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MiniGameIntroductionPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MiniGameIntroductionPayload> CreateMiniGameIntroductionPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> Name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Instruction = 0,
    uint64_t time_left = 0) {
  MiniGameIntroductionPayloadBuilder builder_(_fbb);
  builder_.add_time_left(time_left);
  builder_.add_Instruction(Instruction);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MiniGameIntroductionPayload> CreateMiniGameIntroductionPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    const char *Instruction = nullptr,
    uint64_t time_left = 0) {
  auto Name__ = Name ? _fbb.CreateString(Name) : 0;
  auto Instruction__ = Instruction ? _fbb.CreateString(Instruction) : 0;
  return CreateMiniGameIntroductionPayload(
      _fbb,
      Name__,
      Instruction__,
      time_left);
}

struct MiniGamePayloadType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MiniGamePayloadTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINIGAME = 4,
    VT_GAMESTATETYPE = 6,
    VT_GAMESTATEPAYLOAD_TYPE = 8,
    VT_GAMESTATEPAYLOAD = 10
  };
  const ::flatbuffers::String *minigame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MINIGAME);
  }
  GameStateType gamestatetype() const {
    return static_cast<GameStateType>(GetField<int8_t>(VT_GAMESTATETYPE, 0));
  }
  GameStatePayload gamestatepayload_type() const {
    return static_cast<GameStatePayload>(GetField<uint8_t>(VT_GAMESTATEPAYLOAD_TYPE, 0));
  }
  const void *gamestatepayload() const {
    return GetPointer<const void *>(VT_GAMESTATEPAYLOAD);
  }
  template<typename T> const T *gamestatepayload_as() const;
  const BusinessBailoutHostPayload *gamestatepayload_as_BusinessBailoutHostPayload() const {
    return gamestatepayload_type() == GameStatePayload_BusinessBailoutHostPayload ? static_cast<const BusinessBailoutHostPayload *>(gamestatepayload()) : nullptr;
  }
  const BusinessBailoutPlayerInputPayload *gamestatepayload_as_BusinessBailoutPlayerInputPayload() const {
    return gamestatepayload_type() == GameStatePayload_BusinessBailoutPlayerInputPayload ? static_cast<const BusinessBailoutPlayerInputPayload *>(gamestatepayload()) : nullptr;
  }
  const BusinessBailoutPlayerPayload *gamestatepayload_as_BusinessBailoutPlayerPayload() const {
    return gamestatepayload_type() == GameStatePayload_BusinessBailoutPlayerPayload ? static_cast<const BusinessBailoutPlayerPayload *>(gamestatepayload()) : nullptr;
  }
  const BusinessBailoutResultPayload *gamestatepayload_as_BusinessBailoutResultPayload() const {
    return gamestatepayload_type() == GameStatePayload_BusinessBailoutResultPayload ? static_cast<const BusinessBailoutResultPayload *>(gamestatepayload()) : nullptr;
  }
  const CrazyCountingHostEntitiesPayload *gamestatepayload_as_CrazyCountingHostEntitiesPayload() const {
    return gamestatepayload_type() == GameStatePayload_CrazyCountingHostEntitiesPayload ? static_cast<const CrazyCountingHostEntitiesPayload *>(gamestatepayload()) : nullptr;
  }
  const CrazyCountingPlayerInputPayload *gamestatepayload_as_CrazyCountingPlayerInputPayload() const {
    return gamestatepayload_type() == GameStatePayload_CrazyCountingPlayerInputPayload ? static_cast<const CrazyCountingPlayerInputPayload *>(gamestatepayload()) : nullptr;
  }
  const CrazyCountingPlayerUpdatePayload *gamestatepayload_as_CrazyCountingPlayerUpdatePayload() const {
    return gamestatepayload_type() == GameStatePayload_CrazyCountingPlayerUpdatePayload ? static_cast<const CrazyCountingPlayerUpdatePayload *>(gamestatepayload()) : nullptr;
  }
  const CrazyCountingResultPayload *gamestatepayload_as_CrazyCountingResultPayload() const {
    return gamestatepayload_type() == GameStatePayload_CrazyCountingResultPayload ? static_cast<const CrazyCountingResultPayload *>(gamestatepayload()) : nullptr;
  }
  const MemoryMixerGridPayload *gamestatepayload_as_MemoryMixerGridPayload() const {
    return gamestatepayload_type() == GameStatePayload_MemoryMixerGridPayload ? static_cast<const MemoryMixerGridPayload *>(gamestatepayload()) : nullptr;
  }
  const MemoryMixerPlayerInputPayload *gamestatepayload_as_MemoryMixerPlayerInputPayload() const {
    return gamestatepayload_type() == GameStatePayload_MemoryMixerPlayerInputPayload ? static_cast<const MemoryMixerPlayerInputPayload *>(gamestatepayload()) : nullptr;
  }
  const MemoryMixerPlayerSubmittedPayload *gamestatepayload_as_MemoryMixerPlayerSubmittedPayload() const {
    return gamestatepayload_type() == GameStatePayload_MemoryMixerPlayerSubmittedPayload ? static_cast<const MemoryMixerPlayerSubmittedPayload *>(gamestatepayload()) : nullptr;
  }
  const MemoryMixerResultPayload *gamestatepayload_as_MemoryMixerResultPayload() const {
    return gamestatepayload_type() == GameStatePayload_MemoryMixerResultPayload ? static_cast<const MemoryMixerResultPayload *>(gamestatepayload()) : nullptr;
  }
  const MemoryMixerRoundResultPayload *gamestatepayload_as_MemoryMixerRoundResultPayload() const {
    return gamestatepayload_type() == GameStatePayload_MemoryMixerRoundResultPayload ? static_cast<const MemoryMixerRoundResultPayload *>(gamestatepayload()) : nullptr;
  }
  const MiniGameIntroductionPayload *gamestatepayload_as_MiniGameIntroductionPayload() const {
    return gamestatepayload_type() == GameStatePayload_MiniGameIntroductionPayload ? static_cast<const MiniGameIntroductionPayload *>(gamestatepayload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MINIGAME) &&
           verifier.VerifyString(minigame()) &&
           VerifyField<int8_t>(verifier, VT_GAMESTATETYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_GAMESTATEPAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_GAMESTATEPAYLOAD) &&
           VerifyGameStatePayload(verifier, gamestatepayload(), gamestatepayload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const BusinessBailoutHostPayload *MiniGamePayloadType::gamestatepayload_as<BusinessBailoutHostPayload>() const {
  return gamestatepayload_as_BusinessBailoutHostPayload();
}

template<> inline const BusinessBailoutPlayerInputPayload *MiniGamePayloadType::gamestatepayload_as<BusinessBailoutPlayerInputPayload>() const {
  return gamestatepayload_as_BusinessBailoutPlayerInputPayload();
}

template<> inline const BusinessBailoutPlayerPayload *MiniGamePayloadType::gamestatepayload_as<BusinessBailoutPlayerPayload>() const {
  return gamestatepayload_as_BusinessBailoutPlayerPayload();
}

template<> inline const BusinessBailoutResultPayload *MiniGamePayloadType::gamestatepayload_as<BusinessBailoutResultPayload>() const {
  return gamestatepayload_as_BusinessBailoutResultPayload();
}

template<> inline const CrazyCountingHostEntitiesPayload *MiniGamePayloadType::gamestatepayload_as<CrazyCountingHostEntitiesPayload>() const {
  return gamestatepayload_as_CrazyCountingHostEntitiesPayload();
}

template<> inline const CrazyCountingPlayerInputPayload *MiniGamePayloadType::gamestatepayload_as<CrazyCountingPlayerInputPayload>() const {
  return gamestatepayload_as_CrazyCountingPlayerInputPayload();
}

template<> inline const CrazyCountingPlayerUpdatePayload *MiniGamePayloadType::gamestatepayload_as<CrazyCountingPlayerUpdatePayload>() const {
  return gamestatepayload_as_CrazyCountingPlayerUpdatePayload();
}

template<> inline const CrazyCountingResultPayload *MiniGamePayloadType::gamestatepayload_as<CrazyCountingResultPayload>() const {
  return gamestatepayload_as_CrazyCountingResultPayload();
}

template<> inline const MemoryMixerGridPayload *MiniGamePayloadType::gamestatepayload_as<MemoryMixerGridPayload>() const {
  return gamestatepayload_as_MemoryMixerGridPayload();
}

template<> inline const MemoryMixerPlayerInputPayload *MiniGamePayloadType::gamestatepayload_as<MemoryMixerPlayerInputPayload>() const {
  return gamestatepayload_as_MemoryMixerPlayerInputPayload();
}

template<> inline const MemoryMixerPlayerSubmittedPayload *MiniGamePayloadType::gamestatepayload_as<MemoryMixerPlayerSubmittedPayload>() const {
  return gamestatepayload_as_MemoryMixerPlayerSubmittedPayload();
}

template<> inline const MemoryMixerResultPayload *MiniGamePayloadType::gamestatepayload_as<MemoryMixerResultPayload>() const {
  return gamestatepayload_as_MemoryMixerResultPayload();
}

template<> inline const MemoryMixerRoundResultPayload *MiniGamePayloadType::gamestatepayload_as<MemoryMixerRoundResultPayload>() const {
  return gamestatepayload_as_MemoryMixerRoundResultPayload();
}

template<> inline const MiniGameIntroductionPayload *MiniGamePayloadType::gamestatepayload_as<MiniGameIntroductionPayload>() const {
  return gamestatepayload_as_MiniGameIntroductionPayload();
}

struct MiniGamePayloadTypeBuilder {
  typedef MiniGamePayloadType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_minigame(::flatbuffers::Offset<::flatbuffers::String> minigame) {
    fbb_.AddOffset(MiniGamePayloadType::VT_MINIGAME, minigame);
  }
  void add_gamestatetype(GameStateType gamestatetype) {
    fbb_.AddElement<int8_t>(MiniGamePayloadType::VT_GAMESTATETYPE, static_cast<int8_t>(gamestatetype), 0);
  }
  void add_gamestatepayload_type(GameStatePayload gamestatepayload_type) {
    fbb_.AddElement<uint8_t>(MiniGamePayloadType::VT_GAMESTATEPAYLOAD_TYPE, static_cast<uint8_t>(gamestatepayload_type), 0);
  }
  void add_gamestatepayload(::flatbuffers::Offset<void> gamestatepayload) {
    fbb_.AddOffset(MiniGamePayloadType::VT_GAMESTATEPAYLOAD, gamestatepayload);
  }
  explicit MiniGamePayloadTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MiniGamePayloadType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MiniGamePayloadType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MiniGamePayloadType> CreateMiniGamePayloadType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> minigame = 0,
    GameStateType gamestatetype = GameStateType_BusinessBailoutHost,
    GameStatePayload gamestatepayload_type = GameStatePayload_NONE,
    ::flatbuffers::Offset<void> gamestatepayload = 0) {
  MiniGamePayloadTypeBuilder builder_(_fbb);
  builder_.add_gamestatepayload(gamestatepayload);
  builder_.add_minigame(minigame);
  builder_.add_gamestatepayload_type(gamestatepayload_type);
  builder_.add_gamestatetype(gamestatetype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MiniGamePayloadType> CreateMiniGamePayloadTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *minigame = nullptr,
    GameStateType gamestatetype = GameStateType_BusinessBailoutHost,
    GameStatePayload gamestatepayload_type = GameStatePayload_NONE,
    ::flatbuffers::Offset<void> gamestatepayload = 0) {
  auto minigame__ = minigame ? _fbb.CreateString(minigame) : 0;
  return CreateMiniGamePayloadType(
      _fbb,
      minigame__,
      gamestatetype,
      gamestatepayload_type,
      gamestatepayload);
}

struct FBPlayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FBPlayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct FBPlayerBuilder {
  typedef FBPlayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FBPlayer::VT_NAME, name);
  }
  explicit FBPlayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FBPlayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FBPlayer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FBPlayer> CreateFBPlayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  FBPlayerBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FBPlayer> CreateFBPlayerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateFBPlayer(
      _fbb,
      name__);
}

struct PartyPrepHostInformationPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyPrepHostInformationPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOM_ID = 4,
    VT_PLAYERS = 6
  };
  int64_t room_id() const {
    return GetField<int64_t>(VT_ROOM_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FBPlayer>> *players() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FBPlayer>> *>(VT_PLAYERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ROOM_ID, 8) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.VerifyVector(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           verifier.EndTable();
  }
};

struct PartyPrepHostInformationPayloadBuilder {
  typedef PartyPrepHostInformationPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_room_id(int64_t room_id) {
    fbb_.AddElement<int64_t>(PartyPrepHostInformationPayload::VT_ROOM_ID, room_id, 0);
  }
  void add_players(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBPlayer>>> players) {
    fbb_.AddOffset(PartyPrepHostInformationPayload::VT_PLAYERS, players);
  }
  explicit PartyPrepHostInformationPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyPrepHostInformationPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyPrepHostInformationPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyPrepHostInformationPayload> CreatePartyPrepHostInformationPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t room_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FBPlayer>>> players = 0) {
  PartyPrepHostInformationPayloadBuilder builder_(_fbb);
  builder_.add_room_id(room_id);
  builder_.add_players(players);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PartyPrepHostInformationPayload> CreatePartyPrepHostInformationPayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t room_id = 0,
    const std::vector<::flatbuffers::Offset<FBPlayer>> *players = nullptr) {
  auto players__ = players ? _fbb.CreateVector<::flatbuffers::Offset<FBPlayer>>(*players) : 0;
  return CreatePartyPrepHostInformationPayload(
      _fbb,
      room_id,
      players__);
}

struct PartyPrepHostStartGamePayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyPrepHostStartGamePayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_GAME = 4
  };
  bool start_game() const {
    return GetField<uint8_t>(VT_START_GAME, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_START_GAME, 1) &&
           verifier.EndTable();
  }
};

struct PartyPrepHostStartGamePayloadBuilder {
  typedef PartyPrepHostStartGamePayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_game(bool start_game) {
    fbb_.AddElement<uint8_t>(PartyPrepHostStartGamePayload::VT_START_GAME, static_cast<uint8_t>(start_game), 0);
  }
  explicit PartyPrepHostStartGamePayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyPrepHostStartGamePayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyPrepHostStartGamePayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyPrepHostStartGamePayload> CreatePartyPrepHostStartGamePayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool start_game = false) {
  PartyPrepHostStartGamePayloadBuilder builder_(_fbb);
  builder_.add_start_game(start_game);
  return builder_.Finish();
}

struct PartyPrepPlayerInformationPayload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyPrepPlayerInformationPayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOM_ID = 4
  };
  int64_t room_id() const {
    return GetField<int64_t>(VT_ROOM_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ROOM_ID, 8) &&
           verifier.EndTable();
  }
};

struct PartyPrepPlayerInformationPayloadBuilder {
  typedef PartyPrepPlayerInformationPayload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_room_id(int64_t room_id) {
    fbb_.AddElement<int64_t>(PartyPrepPlayerInformationPayload::VT_ROOM_ID, room_id, 0);
  }
  explicit PartyPrepPlayerInformationPayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyPrepPlayerInformationPayload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyPrepPlayerInformationPayload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyPrepPlayerInformationPayload> CreatePartyPrepPlayerInformationPayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t room_id = 0) {
  PartyPrepPlayerInformationPayloadBuilder builder_(_fbb);
  builder_.add_room_id(room_id);
  return builder_.Finish();
}

struct PartyPrepPayloadType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartyPrepPayloadTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTYPREPTYPE = 4,
    VT_PARTYPREPPAYLOAD_TYPE = 6,
    VT_PARTYPREPPAYLOAD = 8
  };
  PartyPrepType partypreptype() const {
    return static_cast<PartyPrepType>(GetField<int8_t>(VT_PARTYPREPTYPE, 0));
  }
  PartyPrepPayload partypreppayload_type() const {
    return static_cast<PartyPrepPayload>(GetField<uint8_t>(VT_PARTYPREPPAYLOAD_TYPE, 0));
  }
  const void *partypreppayload() const {
    return GetPointer<const void *>(VT_PARTYPREPPAYLOAD);
  }
  template<typename T> const T *partypreppayload_as() const;
  const PartyPrepHostInformationPayload *partypreppayload_as_PartyPrepHostInformationPayload() const {
    return partypreppayload_type() == PartyPrepPayload_PartyPrepHostInformationPayload ? static_cast<const PartyPrepHostInformationPayload *>(partypreppayload()) : nullptr;
  }
  const PartyPrepHostStartGamePayload *partypreppayload_as_PartyPrepHostStartGamePayload() const {
    return partypreppayload_type() == PartyPrepPayload_PartyPrepHostStartGamePayload ? static_cast<const PartyPrepHostStartGamePayload *>(partypreppayload()) : nullptr;
  }
  const PartyPrepPlayerInformationPayload *partypreppayload_as_PartyPrepPlayerInformationPayload() const {
    return partypreppayload_type() == PartyPrepPayload_PartyPrepPlayerInformationPayload ? static_cast<const PartyPrepPlayerInformationPayload *>(partypreppayload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PARTYPREPTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PARTYPREPPAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PARTYPREPPAYLOAD) &&
           VerifyPartyPrepPayload(verifier, partypreppayload(), partypreppayload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const PartyPrepHostInformationPayload *PartyPrepPayloadType::partypreppayload_as<PartyPrepHostInformationPayload>() const {
  return partypreppayload_as_PartyPrepHostInformationPayload();
}

template<> inline const PartyPrepHostStartGamePayload *PartyPrepPayloadType::partypreppayload_as<PartyPrepHostStartGamePayload>() const {
  return partypreppayload_as_PartyPrepHostStartGamePayload();
}

template<> inline const PartyPrepPlayerInformationPayload *PartyPrepPayloadType::partypreppayload_as<PartyPrepPlayerInformationPayload>() const {
  return partypreppayload_as_PartyPrepPlayerInformationPayload();
}

struct PartyPrepPayloadTypeBuilder {
  typedef PartyPrepPayloadType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_partypreptype(PartyPrepType partypreptype) {
    fbb_.AddElement<int8_t>(PartyPrepPayloadType::VT_PARTYPREPTYPE, static_cast<int8_t>(partypreptype), 0);
  }
  void add_partypreppayload_type(PartyPrepPayload partypreppayload_type) {
    fbb_.AddElement<uint8_t>(PartyPrepPayloadType::VT_PARTYPREPPAYLOAD_TYPE, static_cast<uint8_t>(partypreppayload_type), 0);
  }
  void add_partypreppayload(::flatbuffers::Offset<void> partypreppayload) {
    fbb_.AddOffset(PartyPrepPayloadType::VT_PARTYPREPPAYLOAD, partypreppayload);
  }
  explicit PartyPrepPayloadTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartyPrepPayloadType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartyPrepPayloadType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartyPrepPayloadType> CreatePartyPrepPayloadType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    PartyPrepType partypreptype = PartyPrepType_PartyPrepHostInformation,
    PartyPrepPayload partypreppayload_type = PartyPrepPayload_NONE,
    ::flatbuffers::Offset<void> partypreppayload = 0) {
  PartyPrepPayloadTypeBuilder builder_(_fbb);
  builder_.add_partypreppayload(partypreppayload);
  builder_.add_partypreppayload_type(partypreppayload_type);
  builder_.add_partypreptype(partypreptype);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  MessageType type() const {
    return static_cast<MessageType>(GetField<int8_t>(VT_TYPE, 0));
  }
  Payload payload_type() const {
    return static_cast<Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const HostPayloadType *payload_as_HostPayloadType() const {
    return payload_type() == Payload_HostPayloadType ? static_cast<const HostPayloadType *>(payload()) : nullptr;
  }
  const JoinPayloadType *payload_as_JoinPayloadType() const {
    return payload_type() == Payload_JoinPayloadType ? static_cast<const JoinPayloadType *>(payload()) : nullptr;
  }
  const LeaderboardPayloadType *payload_as_LeaderboardPayloadType() const {
    return payload_type() == Payload_LeaderboardPayloadType ? static_cast<const LeaderboardPayloadType *>(payload()) : nullptr;
  }
  const MiniGamePayloadType *payload_as_MiniGamePayloadType() const {
    return payload_type() == Payload_MiniGamePayloadType ? static_cast<const MiniGamePayloadType *>(payload()) : nullptr;
  }
  const PartyPrepPayloadType *payload_as_PartyPrepPayloadType() const {
    return payload_type() == Payload_PartyPrepPayloadType ? static_cast<const PartyPrepPayloadType *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const HostPayloadType *Message::payload_as<HostPayloadType>() const {
  return payload_as_HostPayloadType();
}

template<> inline const JoinPayloadType *Message::payload_as<JoinPayloadType>() const {
  return payload_as_JoinPayloadType();
}

template<> inline const LeaderboardPayloadType *Message::payload_as<LeaderboardPayloadType>() const {
  return payload_as_LeaderboardPayloadType();
}

template<> inline const MiniGamePayloadType *Message::payload_as<MiniGamePayloadType>() const {
  return payload_as_MiniGamePayloadType();
}

template<> inline const PartyPrepPayloadType *Message::payload_as<PartyPrepPayloadType>() const {
  return payload_as_PartyPrepPayloadType();
}

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(MessageType type) {
    fbb_.AddElement<int8_t>(Message::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_payload_type(Payload payload_type) {
    fbb_.AddElement<uint8_t>(Message::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Message::VT_PAYLOAD, payload);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MessageType type = MessageType_Host,
    Payload payload_type = Payload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline bool VerifyLeaderboardPayload(::flatbuffers::Verifier &verifier, const void *obj, LeaderboardPayload type) {
  switch (type) {
    case LeaderboardPayload_NONE: {
      return true;
    }
    case LeaderboardPayload_LeaderboardInformationPayload: {
      auto ptr = reinterpret_cast<const LeaderboardInformationPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LeaderboardPayload_LeaderboardHostSkipPayload: {
      auto ptr = reinterpret_cast<const LeaderboardHostSkipPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLeaderboardPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLeaderboardPayload(
        verifier,  values->Get(i), types->GetEnum<LeaderboardPayload>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGameStatePayload(::flatbuffers::Verifier &verifier, const void *obj, GameStatePayload type) {
  switch (type) {
    case GameStatePayload_NONE: {
      return true;
    }
    case GameStatePayload_BusinessBailoutHostPayload: {
      auto ptr = reinterpret_cast<const BusinessBailoutHostPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_BusinessBailoutPlayerInputPayload: {
      auto ptr = reinterpret_cast<const BusinessBailoutPlayerInputPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_BusinessBailoutPlayerPayload: {
      auto ptr = reinterpret_cast<const BusinessBailoutPlayerPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_BusinessBailoutResultPayload: {
      auto ptr = reinterpret_cast<const BusinessBailoutResultPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_CrazyCountingHostEntitiesPayload: {
      auto ptr = reinterpret_cast<const CrazyCountingHostEntitiesPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_CrazyCountingPlayerInputPayload: {
      auto ptr = reinterpret_cast<const CrazyCountingPlayerInputPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_CrazyCountingPlayerUpdatePayload: {
      auto ptr = reinterpret_cast<const CrazyCountingPlayerUpdatePayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_CrazyCountingResultPayload: {
      auto ptr = reinterpret_cast<const CrazyCountingResultPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_MemoryMixerGridPayload: {
      auto ptr = reinterpret_cast<const MemoryMixerGridPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_MemoryMixerPlayerInputPayload: {
      auto ptr = reinterpret_cast<const MemoryMixerPlayerInputPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_MemoryMixerPlayerSubmittedPayload: {
      auto ptr = reinterpret_cast<const MemoryMixerPlayerSubmittedPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_MemoryMixerResultPayload: {
      auto ptr = reinterpret_cast<const MemoryMixerResultPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_MemoryMixerRoundResultPayload: {
      auto ptr = reinterpret_cast<const MemoryMixerRoundResultPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameStatePayload_MiniGameIntroductionPayload: {
      auto ptr = reinterpret_cast<const MiniGameIntroductionPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGameStatePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGameStatePayload(
        verifier,  values->Get(i), types->GetEnum<GameStatePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPartyPrepPayload(::flatbuffers::Verifier &verifier, const void *obj, PartyPrepPayload type) {
  switch (type) {
    case PartyPrepPayload_NONE: {
      return true;
    }
    case PartyPrepPayload_PartyPrepHostInformationPayload: {
      auto ptr = reinterpret_cast<const PartyPrepHostInformationPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PartyPrepPayload_PartyPrepHostStartGamePayload: {
      auto ptr = reinterpret_cast<const PartyPrepHostStartGamePayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PartyPrepPayload_PartyPrepPlayerInformationPayload: {
      auto ptr = reinterpret_cast<const PartyPrepPlayerInformationPayload *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPartyPrepPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPartyPrepPayload(
        verifier,  values->Get(i), types->GetEnum<PartyPrepPayload>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload_NONE: {
      return true;
    }
    case Payload_HostPayloadType: {
      auto ptr = reinterpret_cast<const HostPayloadType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_JoinPayloadType: {
      auto ptr = reinterpret_cast<const JoinPayloadType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_LeaderboardPayloadType: {
      auto ptr = reinterpret_cast<const LeaderboardPayloadType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_MiniGamePayloadType: {
      auto ptr = reinterpret_cast<const MiniGamePayloadType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_PartyPrepPayloadType: {
      auto ptr = reinterpret_cast<const PartyPrepPayloadType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline const Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Message>(buf);
}

inline const Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Message> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_MESSAGECLASS_H_
